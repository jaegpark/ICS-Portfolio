<!DOCTYPE html>
<html>
  <head>
    <style>
      table, td{
        border: 1px solid white;
      }
    </style>
    <link href="https://fonts.googleapis.com/css?family=Work+Sans:400" rel="stylesheet">
    <link href="style.css" rel="stylesheet" type="text/css">
    <meta charset="UTF-8">
    <meta name="description" content="OOP">
    <title>ICS4U0 - OOP</title>
  </head>

<body>
  <header>
    <nav>
      <p><a href = "index.html">Jae Park</a></p>
       <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="about.html">About</a></li>
        <li><a href="#">ICS4U0</a>
            <ul>
              <li><a href=ics4uo.html>Introduction</a></li>
              <li><a href="oop1.html">OOP</a></li>
              <li><a href="arrays-arraylists.html">Arrays and ArrayLists</a></li>
              <li><a href="sorting.html">Sorting</a></li>
              <li><a href="searching.html">Searching</a></li>
              <li><a href="recursion.html">Recursion</a></li>
            </ul>
        </li>
        <li><a href="contact.html">Contact</a></li>
        <li><a href="projects.html">Projects</a><li>
      </ul>
    </nav>
  </header>

  <main>
    <h2>OOP - Object Oriented Programming</h2>
    <br><hr><br><br>
    <h3>What is OOP in Java?</h3>
    <br>
    <p>
      OOP, or Object Oriented Programming, is a style of programming that involves the manipulation of Objects and their attributes/behaviours. There
      are 4 fundamental principles within OOP: inheritance, abstraction, encapsulation, and polymorphism. In this tutorial, I will guide you through
      these 4 principles, with code examples in between. But to start, it is important to get the fundamental concepts such as classes, objects, and
      methods properly set. Let's begin.
    </p>
    <br><hr><br><br>
    <article>
      <h3>Objects and Classes</h3>
      <br>
      <h4><u>What are they?</u></h4>
      <br>
      <p>
        To get an understanding of objects in Java, let's first see what an object is in real life. Think of some real word objects.
        Cats, dogs, cars, humans, pencils... so many more! If we think about it, all of these objects have a state and behaviour.
        We can then think of objects in Java similarly. These objects in Java store their states in variable fields, and store their
        behaviours into blocks of codes called methods.
      </p>
      <br>
      <p>
        For example, a cat object would have states such as a name, breed, and colour, and would have
        behaviours such as meowing, eating, and drinking. Such objects, in Java, come from instances of Classes...
      </p>
      <br>
      <p>
        Wait, what is a class?
      </p>
      <br>
      <p>
        Classes in Java are like blueprints/templates on how to build an Object. It would define the basic attributes that each instance of itself would contain.
        For example, a Cat class would have attributes/variables of breed, colour, and name, and have behaviours/methods of meowing, eating, and drinking.
        The following would be a template of a Cat class.
      </p>
      <br>
      <p>
        <pre>
          <code>
            public class Cat{   // note that it is a convention to capitalize names of classes, and camel-case all names.
              String name;
              String colour;
              String breed;

              void meow(){
                // code for meow method here
              }

              void eat(){
                // code for eat method here
              }

              void drink(){
                // code for drink method here
              }
            }
          </code>
        </pre>
      </p>
      <br>
      <h4><u>Variables inside classes</u></h4>
      <br>
      <p>
        We just learned that the states of objects are stored inside variables.
        In Java classes, there are three types of variables that can be found:
      </p>
      <br>
      <ul>
        <li><b>Local variables</b> : these are varaibles which are declared inside a method. They are called
        local, since the data/memory allocated for this variable will be removed from the stack (a place in memory),
        once the method has finished execution.
        </li>
        <br>
        <li><b>Instance varaibles</b> : these are variables which are declared within a class, but not within a method.
        These are intialized during class instantiation, or in other words, when an instance of the class is made.
        These variables are also sometimes called global variables, since they are accessable by any method inside
        the same class.
        </li>
        <br>
        <li><b>Class/static variables</b> : these are varaibles declared within a class, outside any method, with the "static"
        keyword. These variables, unlike instance varaibles, do not require an object of the class to be made before using it.
        </li>
      </ul>
      <br><br>
    </article>
    <!-- methods -->
    <article>
      <h3>Methods</h3>
      <br><hr><br>
      <h4><u>What are they?</u></h4>
      <br>
      <p>
        In Java, a method is a block of code which is only run when the method is called. In other programming languages,
        methods can sometimes be called functions or procedures. Often times, methods are designed to do specific tasks within a
        program. Together with other methods, they allow the program to run properly.
        Additionally, in Java, methods can be given parameters (data passed into a method) to manipulate. We will touch on this later.
      </p>
      <br>
      <p>
        It is important to note that in Java, methods cannot be written by themselves. They MUST be written inside a class.
        Methods are defined by a name, followed by a set of parantheses().
        Although Java brings in default libraries which contain a multitude of classes and their methods, often times, programmers
        program their own methods, to do exactly what they want.
      </p>
      <br>
      <p>
        For example, let's look at a method header of a method called "calculate" inside the class Demo.
        <pre>
          <code>
            public class Demo{
              void calculate(){
                // code for method goes here.
              }
            }
          </code>
        </pre>
      </p>
      <p>
        You may have noticed the "void" keyword there in front of the method name. Don't worry, all that means for now
        is that the method has no return value.
      </p>
      <br>
      <h4><u>Parameters</u></h4>
      <br>
      <p>
        It was mentioned before that data could be passed into a method through "parameters."
        Essentially, a parameter is a piece of information that is passed into an array. These parameters are
        declared inside the parantheses. There is no limit to the number of parameters you can have
        inside a method. Just make sure that they are all separated with commas.
        It is advised though to minimize the number of parameters, for the sake of program
        clarity. Remember, a method call will be invalid unless all parameter values have been passed in, IN CHRONOLOGICAL
        ORDER.
      </p>
      <br>
      <p>
        Let's look at this example here. In this method called "add", we will have two int parameters.
        The method will output the value of the sum of these two numbers.
      </p>
      <br>
      <p>
        <pre>
          <code>
            public class Demo1{
              public static void add(int firstNumber, int secondNumber){
                System.out.println(firstNumber+secondNumber);
              }

              public static void main(Stirng[] args){
                add(5, 2);  // will call the add method with the firstNumber parameter value of 5, and secondNumber value of 2.
                            // this will print the value of 7.
              }
            }
          </code>
        </pre>
      </p>
      <br>
      <h4><u>Passing into methods</u></h4>
      <br>
      <p>
        In Java, there are two ways to pass parameters into a method: pass by value and pass by reference.
      </p>
      <br>
      <ul>
        <li>
          Pass by value: pass by value is when the method parameter values are copied to another variable. This new variable is then passed and
          manipuated on.
        </li>
        <li>
          Pass by reference: this is when a reference pointer is passed into the method.
        </li>
      </ul>
      <br>
      <p>
        Let's take a look at an example:
      </p>
      <br>
      <h4><u>Return Types</u></h4>
      <br>
      <p>
        In the examples you've seen so far, you have seen the keyword "void" be used multiple times. What does that
        really mean though? In Java, methods have certain return types. The void keyword indicates that the method
        does not actually return anything. To have a method return a value, whether it be an object or primitive data,
        all you need to do is add the name of the datatype's name in the method header.
        Remember, all return-type methods MUST contain the keyword "return" inside the method. This return statement
        must be reachable, regardless of the code inside the method.
      </p>
      <br>
      <p>
        Note: a return method does not actually output anything! To print something returned by a return-method,
        a print statement is often called to the return value of the method.
      </p>
      <br>
      <p>
        Let's look at this example: this is similar code to the Demo1 class. The method add takes in two ints to add,
        and returns the value of their sum.
      </p>
      <br>
      <p>
        <code>
          <pre>
            public class Demo2{
              public static int add(int firstNumber, int secondNumber){
                return (firstNumber+secondNumber);
              }

              public static void main(String [] args){
                System.out.println(add(2, 3));
              }
            }
          </pre>
        </code>
      </p>
      <!-- mutator/accessor methods -->
      <h4><u>Mutator/accessor methods</u></h4>
      <br>
      <p>
        In classes, special methods are used that are usually named getSOMETHING() and setSOMETHING().
        These methods are called getters/setters, or accessor/mutator methods. These, in convention,
        are used to return/change the values of a class' attributes. These attributes are usually unable
        to be directly accessed by outer classes. This will be explained further under encapsulation.
      </p>
      <br>
      <p>
        Let's look at an example:
      </p>
      <br>
      <p>
        <pre>
          <code>
            public class Demo3{
              String name;

              public void setName(String n){
                name = n;           // this sets the Demo3 classes name attribute to a new String value passed in as a parameter
              }

              public String getName(){
                return name;        // this method returns the value of the name attribute
              }
            }
          </code>
        </pre>
      </p>
      <br>
      <!--constructors -->
      <h4><u>Constructors</u></h4>
      <br>
      <p>
        Constructors are special methods inside classes, which help with the instantiation of an object
        of its class. They are declared without a specified return type, and can have parameters passed in. They
        must be named after their Class name, and there can be many constructors inside a class, as long as
        they have different parameter values. This concept of having multiple methods named the same thing is
        called "overloading" methods.
      </p>
      <br>
      <p>
        Often, constructors have passed in parameters that help set the values of the attributes/states of the Object.
        Let's take a look at an example of a few constructors.
      </p>
      <br>
      <p>
        <pre>
          <code>
            public class Student{
              private String name;
              private long studentNumber;
              private int lockerNumber;

              public Student(){   // this is the default constructor - it has no arguments/parameters passed in.
                    // initially, if this constructor is used, all of the instance's/object's attributes are pointed to null.
              }

              public Student(String studentName, long studentNum){  // this constructor takes in two attribute fields
                name = studentName;
                studentNumber = studentNum;
              }

              public Student(String studentName, long studentNum, int locker){  // this constructor takes in all attribute fields
                name = studentName;
                studentNumber = studentNum;
                lockerNumber = locker;
              }
            }
          </code>
        </pre>
      </p>
      <br>
      <p>
        It is important to note that Java, by default, will create a default no argument constructor in case it was
        not made in the class already. This is done to avoid compiling errors.
      </p>
      <br><br>
    </article>

    <!--encapsulation-->
    <article>
      <h3>Encapsulation</h3>
      <br><hr><br>
      <h4><u>What is it?</u></h4>
      <br>
      <p>
        In Java, there are keywords that can specify "visibility/accessibility" of something. When declaring a class, you may have
        noticed that we include the keyword "public." In Java, this means that the class is accessible by other classes in the same
        file location, which may want to use it to create objects. Think of encapsulation as a shield which controls what code from
        outside the class can access the data inside it.
      </p>
      <br>
      <p>
        For common convention, it is often the case where instance variables are not accessable publicly/
        by outside the class. Instead, these are private fields, and are accessed using public methods written
        in the same class. You saw these earlier: the mutator/accessor methods.
      </p>
      <br>
      <p>
        The reason for keeping fields private is to avoid unwanted external code from disrupting their values.
        However, note that there are other cases where other levels of encapsulation are desired. In Java, there
        are three different levels of encapsuation:
      </p>
      <br>
      <p>
       They are achieved thorugh keywords:
       <br><br>
        <ul>
          <li>public: this indicates that it is accessable from anywhere within the same local file.</li>
          <li>private this indicates that it is only accessable within the class itself. </li>
          <li>protected: this indicates that it is only accessable within the same class heirarchy.</li>
        </ul>
      </p>
      <br>
      <p>
        Let's look at an example of fully encapsulating a class:
      </p>
      <br>
      <pre>
        <code>
          public class Person{
            private String name;
            private int age;
            public int getAge(){
              return age;
            }
            public String getName(){
              return name;
            }
            public void setAge(int newAge){
              age = newAge;
            }
            public void setName(String newName){
              name = newName;
            }
          }
        </code>
      </pre>
      <br>
      <p>
        This allows the methods, getAge(), getName(), setAge(), and setName() to be used in
        other classes in the same file. The instance variables name and age will not be
        able to be directly used in outer classes. The only way of modifying these values of the
        object would be to use these mutator methods.
      </p>
      <br><br>
    </article>

    <!--inheritance-->
    <article>
      <h3>Inheritance</h3>
      <br><hr><br>
      <p>
        In Java, a class can have a direct relationship with another class, by extending it. Using the extends keyword,
        a class can extend another class, inheriting all of its attributes and behaviours (its varaibles and methods).
        This is what we call inheritance. This is useful when creating many classes that will interact with each other in
        a full program. Let's look at an example below:
      </p>
      <br>
      <p>
        Consider the following classes: Cat, Dog, and Pet
        <pre>
          <code>
            public class Cat{
              private String name;
              private String breed;

              public Cat(String n, String b){
                name = n;
                breed = b;
              }

              public void feed(){
                // code not shown
              }
              public void meow(){
                // code not shown
              }
            }

            public class Dog{
              private String name;
              private String breed;

              public Dog(String s, String b){
                name = s;
                breed = b;
              }

              public void feed(){
                // code not shown
              }

              public void bark(){
                // code not shown
              }

            }

            public class Pet{
              private String name;
              private String breed;

              public void feed(){
                // code not shown
              }
            }
          </code>
        </pre>
        <br>
      </p>
      <p>
        You see how Cat and Dog both contain <i>common</i> elements, that are in every Pet class?
        They all share the same fields (name, breed), and all have void methods (feed()) that feed the pet.
        To simplify this in Java, we can consider Cat and Dog "subclasses" of the Pet "superclass."
        You can often tell if something is a subclass of another thing, if there is a "is-a" relationship.
      </p>
      <br>
      <p>
        For example:
        <br><br>
        <ul>
          <li>a Cat is-a Pet. Therefore, Cat is a subclass of Pet.</li>
          <li>a Dog is-a Pet. Therefore, Dog is a subclass of Pet.</li>
          <li>a Pet is-a Dog? No! Not all pets are dogs. This is how you know that Pet is not a subclass of Dog.</li>
      </p>
      <br>
      <p>
        Using this new knowledge of subclasses and superclasses, we can make the Dog and Cat class inherit the
        data from the Pet superclass. This is what the simplified version would look like below:
      </p>
      <br>
      <p>
        <pre>
          <code>
            public class Cat extends Pet{
              public Cat(String n, String b){
                super(n, b);
              }
              public void meow(){
                // code not shown
              }
            }

            public class Dog extends Pet{
              public Dog(String n, String b){
                super(n, b);
              }
              public void bark(){
                // code not shown
              }
            }

            public class Pet{
              private String name;
              private String breed;
              public Pet(String petName, String petBreed){
                name = petName;
                breed = petBreed;
              }
              public void feed(){
                // code not shown
              }
            }
          </code>
        </pre>
        <br>
        Here, we do not need to have the feed() method inside each subclass, since the subclasses will inherit the method from
        the superclass. This means, that in a client program, this:
        <br>
        <pre>
          <code>
            Dog dog1 = new Dog("Jeff", "Golden Retriever");
            dog1.feed();
          </code>
        </pre>
        will run without error. To find the feed() method, Java, during runtime, will go through the object's class' heirarchy to
        look for the first method found with the same name. If one is not found, a SOMETHINGSOMETHING exception will be thrown.
      </p>
      <br>
      <p>
        Note: a subclass can also be a superclass to another subclass. There is no limit on the length of this inheritance/heirarchy tree.
        Just remember that the class at the bottom of this inheritance will inherit EVERYTHING.
      </p>
      <br><br>
    </article>

    <!-- abstraction -->
    <article>
      <h3>Abstraction</h3>
      <br><hr><br>
      <h4><u>What is it?</u></h4>
      <br>
      <p>
        In Java, there is a keyword "abstract" which can be applied to methods, variables, and even entire classes.
        The abstract keyword indicates that you are dealing with an <i> idea </i>, rather than an actual <i>events.</i>
      </p>
      <br>
      <p>
        When speaking about OOP, classes, methods, and variables are usually abstracted to hide the code implementation from
        the user. In OOP, there are two ways you can achieve abstraction: through abstract classes or through an interface.
      </p>
      <br>
      <h4><u>Abstract Classes</u></h4>
      <br>
      <p>
        An abstract class can easily be identified if it contains the keyword "abstract" in the class declaration. In Java,
        abstract classes will have the following properties:
      </p>
      <br>
      <ul>
        <li>Abstract classes will OR will not contain abstract methods. As a side note, abstract methods in abstract classes
        are written without a code body block. For example: (public void doSomething();), would be how the method actually looks like
        inside an abstract class.</li>
        <li>Abstract classes cannot be instantiated by itself, to create objects. </li>
        <li>To use an abstract class, it must be inherited by another non-abstract class, which will need to implement its methods.</li>
        <li>If an abstract class is extended, all of its abstract methods must be implemented.</li>
      </ul>
      <br>
      <h4><u>Interfaces</u></h4>
      <br>
      <p>
        In Java, another way to achieve abstraction is by using interfaces. Interfaces are essentially FULL abstract classes.
        All of its variables and methods are by default, abstract. Here are the key takeaways:
      </p>
      <br>
      <ul>
        <li>Methods inside interfaces are all abstract, and by default public.</li>
        <li>Variables in interfaces are public, static, and final. </li>
        <li>Interfaces cannot be instantiated by itself, to create objects. </li>
        <li>Interfaces cannot contain contructors.</li>
        <li>To use an interface, it must be implemented inside another class (using the keyword "implements"), which will need to implement all of its methods.</li>
      </ul>
      <br>
      <p>
      Let's look at an example of an interface being implemented:
      <pre>
          <code>
            public interface Pet{
              public void makeNoise();
              public void eat();
            }

            public class Dog implements Pet{
              public void makeNoise(){
                System.out.println("Woof");
              }
            }

            public class Driver{
              public static void main(String [] args){
                Dog newDog = new Dog();   // default Dog object created
                newDog.makeNoise();
              }
            }
          </code>
        </pre>
      </p>
      <br><br>
    </article>

    <!-- polymorphism -->
    <article>
      <h3>Polymorphism</h3>
      <br><hr><br>
      <h4><u>What is it?</u></h4>
      <br>
      <p>
        When you learned about inheritance, you may have realized in the shown example that you could call an instance of Dog a Pet,
        similarly, an instance of Cat a Pet. It is this ability for objects to take on many forms/names, which we call polymorphism.
      </p>
      <br>
      <p>
        The general rule of thumb to determine if something is polymorphic, is to see if it has more than one "is-a" relationship
        with other classes. Technically, in Java, all objects extend the Object class, so every object in Java is polymorphic (is-a relationship
        with itslef, and with Object).
      </p>
      <br>
      <p>
        When using methods of a polymorphic class, Java will take the first method it can find in runtime in its class heirarchy. Let's
        look at an example below:
      </p>
      <br>
      <p>
        <pre>
          <code>
            public class Toy{
              public void makeNoise(){
                System.out.println("The toy made a noise!");
              }
            }

            public class Racecar extends Toy{
              public void makeNoise(){
                System.out.println("The car went vroom!");
              }
            }

            public class PoliceCar extends Toy{
              public void makeNoise(){
                System.out.println("The police car went bee-woo-bee-woo!");
              }
            }

            public class Driver1{
              public static void main(String [] args){
                Toy toy1 = new Toy();
                Toy toy2 = new Racecar();
                Toy toy3 = new PoliceCar();

                toy1.makeNoise();
                toy2.makeNoise();
                toy3.makeNoise();
              }
            }
          </code>
        </pre>
        <br>
        <p>
          It turns out that the output for this code is:
          <br><br>
          The toy made a noise!
          <br>
          The car went vroom!
          <br>
          The police car went bee-woo-bee-woo!
        </p>
      </p>
      <br>
      <p>
        In conclusion, we can say that the action the makeNoise() method performed was based on the type of object
        it was called on. It is an example of polymorphism, because
      </p>
      <br><br>
    </article>
    <!-- heirarchy trees -->
    <article>
      <h3>Heirarchy trees</h3>
      <br><hr><br>
      <p>
        When describing class relationships in Java, there is a very useful diagram to use, called a class heirarchy tree.
        In heirarchy trees, classes are surrounded by rectangles, and have arrows demonstrating their relationships with each other.
      </p>
      <br><br>
    </article>
    <!--OOP vs Procedural-->
    <article>
      <h3>OOP vs Procedural Programming</h3>
      <br><hr><br>
      <p>
        To make things a bit easier to understand, I will compare and contrast the differences between object-oriented-programming and
        procedural programming.
      </p>
      <br>
      <p>
      <center>
      <table>
        <caption>OOP vs Procedural Programming</caption>
          <tr>
            <th>OOP</th>
            <th>Procedural Programming</th>
          </tr>
          <tr>
            <td>based on objects of classes</td>
            <td>based on ordered procedures/methods</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
          </tr>
        </table>
      </center>
    </p>
    </article>
    <!--Don't fear the oop assignment example starts here-->
    <article>
      <h3>School and Things - A Short Example</h3>
      <br><hr><br>
      <p>
        As a project for the ICS4U0 course I took, my partner Josh and I wrote a little story to help explain OOP concepts.
        This is an example that demonstrates different levels of explainations of Object Oriented Programming, using a story.
        This story is one where the TDSB must make a blueprint design for the future construction of their high schools.
      </p>
      <br>
      <p>
        In this guide, you will find that sections are separated by green, yellow, and red blocks. These indicate their
        levels of resemblance to how an actual program would be written, where red is the actual cold, yellow is the
        pseudocode, and green is in plain English. You can find it here:
      </p>
      <br>
        <embed src="DontFearTheOOP.pdf#toolbar=0" type="application/pdf" width="100%" height="600px"/>
      <br><br>
    </article>
  </main>
</body>
</html>
