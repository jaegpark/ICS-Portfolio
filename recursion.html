<!DOCTYPE html>
<html>
  <head>
    <link href="https://fonts.googleapis.com/css?family=Work+Sans:400" rel="stylesheet">
    <link href="style.css" rel="stylesheet" type="text/css">
    <meta charset="UTF-8">
    <meta name="description" content="Recursion">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
    <title>ICS4U0 - Recursion</title>
  </head>

<body>
  <header>
    <nav>
      <p><a href = "index.html">Jae Park</a></p>
       <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="about.html">About</a></li>
        <li><a href="#">ICS4U0</a>
            <ul>
              <li><a href=ics4uo.html>Introduction</a></li>
              <li><a href="oop1.html">OOP</a></li>
              <li><a href="arrays-arraylists.html">Arrays and ArrayLists</a></li>
              <li><a href="sorting.html">Sorting</a></li>
              <li><a href="searching.html">Searching</a></li>
              <li><a href="recursion.html">Recursion</a></li>
              <li><a href="bibliography.html">Bibliography</a></li>
            </ul>
        </li>
        <li><a href="contact.html">Contact</a></li>
        <li><a href="projects.html">Projects</a><li>
      </ul>
    </nav>
  </header>

  <main>
    <h1>Recursion</h1>
    <article>
      <br><hr><br>
      <p>
        In Java, recursion is the repeated application of a certain method. In essence, when the method is called once, the method
        calls itself again until a certain base condition has been met. These methods are called recursive methods/functions.
        Recursion is often used in programming to write cleaner, shorter, and more efficient code.
      </p>
      <br>
      <p>
        For a problem to be solved by a recursive function, it must be:
      </p>
      <br>
      <p>
        <ol>
          <li>There must be a to break down the problem into smaller tasks.</li>
          <li>There must be a "base case" to identify when the recursive call stops.</li>
          <li>There must be a way to combine the smaller parts into a large part, ending with the answer.</li>
        </ol>
      </p>
      <br>
      <p>
        In this tutorial, I will be explaining what base cases are, tail recursion, and a few examples.
      </p>
      <br>
      <h2>Base Cases</h2>
      <br>
      <p>
        In a recursive method, there is always a condition that must be met so that the method will not call itself forever!
        This is called the base case, and it often involves the passed in parameters reaching a certain point.
      </p>
      <br>
      <h2>Stack Trace</h2>
      <br>
      <p>
        In essence, a stack trace is a trace of method calls since the beginning of program execution. When a new method is called,
        its call is added onto the top of the stack trace. Java will automatically generate and throw this when there has been a
        StackOverflowError thrown by the JVM.
      </p>
      <br>
      <p>
        Programmers can also use this tool to easily find the source of their error. As well, a stack trace can be used to help
        visualize the recursive function of a problem. Here is an example of a stack trace for the factorial method:
      </p>
      <br>
      <p>
        <pre class="prettyprint">
          <code>
            public static long factorial (int n){
                if (n==0) return 1;
                else
                  return n * factorial(n-1);
              }
          </code>
        </pre>
        <br>
        <pre>
          factorial(5)
            5 * factorial(4)
              4 * factorial(3)
                3 * factorial(2)
                  2 * factorial(1)
                    1 * factorial(0)
                    1*1
                  2 * 1
                3 * 2
              4 * 6
            5 * 24
          120
        </pre>
      </p>
      <br>
      <h2>Types of Recursion</h2>
      <br>
      <h4><u>Tail Recursion</u></h4>
      <br>
      <p>
        Tail recursion is very similar to single method recursion, but it involves putting the recursive call at the end of the method.
        This means that there are no calculations performed after the return of the recursive call.
      </p>
      <br>
      <h4><u>Mutual Recursion</u></h4>
      <br>
      <p>
        Mutual recursion is when two methods are defined in terms of each other, until one terminates.
      </p>
      <br><br>
      <h2>Iteration vs Recursion</h2>
      <br>
      <p>
        While recursion involves the method calling itself until meeting a base case,
        iteration involves a control variable inside a loop determining when to exit the loop.
        Often, recursive solutions take up more memory and time than iterative solutions, unless certain optimizations
        were put into place (such as tail recursive structure). It is also to note that
        infinite recursive loops will crash the program, while infinite iterative cycles will consume more CPU power.
        The benefit of recursion over iterative style is that it keeps code short and concise.
      </p>
      <br>
      <h2>Example Application: Factorial</h2>
      <br>
      <p>
        Problem: design a program that will recursively calculate the factorial value for any given integer n.
        <br>
        Solution: My solution can be found in the factorial(int n) method. The demo value for n is 5.
        <br><br>
        <pre class="prettyprint">
          <code>
            public class FactorialDemo{
              public static long factorial (int n){
                if (n==0) return 1;
                else
                  return n * factorial(n-1);
              }

              public static void main (String [] args){
                System.out.println(factorial(5)); // this outputs 120
              }
            }  </code>
        </pre>
        <br>
      </p>
      <br>
      <h2>Example Application : Maze</h2>
      <br>
      <p>
        In my ICS4U0 class, we were given a 5x5 int array, where 0's represented paths and 1's represented walls.
        Possible entrances to the maze were on the left-most column or the top-most row, and any possible exits were
        on the right-most column and the bottom-most row. An entrance could not be an exit itself. We were asked to
        design a recursive solution. Here it is:
        <br><br>
        <pre class="prettyprint">
          <code>
            /**
             * This class demonstrates the usage of a recursive method, which is used
             * to traverse a 5x5 integer array of 0's and 1's, to determine if a path
             * of 0s exits from an entrance on the first column or row, to an exit
             * located on the 5th column or row.
             * The recursive algorithm used is a variation of a depth first search, dfs, which
             * is commonly applied in graph theory.
             * @author Jae Park
             * @version 1.0 April 14, 2019
             */
            public class Maze {

                static int[][] theMaze = {{0, 1, 1, 1, 1}, {1, 1, 1, 1, 1}, {0, 1, 1, 1, 1}, {0, 0, 1, 1, 1}, {1, 0, 0, 0, 0}};

                /**
                 * This is the boolean method that checks if the two given integer coordinates are within the maze.
                 *
                 * @param x This is the integer value that represents the row number of the maze.
                 * @param y This is the integer value that represents the column number of the maze.
                 * @return This returns a boolean, depending on whether the row and column numbers are inside the maze.
                 *
                 * <b>Local Variables: None.</b>
                 */
                private static boolean isInMaze(int x, int y) {
                    if ((x > -1 && y > -1) && (x < 5 && y < 5)) return true;
                    else return false;
                }

                /**
                 * This is the recursive boolean method that performs a dfs (depth first search) on the maze. It
                 * recursively checks a grid's neighbouring grid elements, and its base case is to see whether
                 * a row or column value is equal to 4 (the max row/col).
                 *
                 * @param maze
                 * @param row
                 * @param col
                 * @return <b>Local variables: None.</b>
                 */
                private static boolean dfs(int[][] maze, int row, int col) {
                    if (!isInMaze(row, col) || maze[row][col] == 1)
                        return false;
                    if (maze[row][col] == 0 && (row == 4 || col == 4))
                        return true;
                    maze[row][col] = 1;
                    return (dfs(maze, row + 1, col) || dfs(maze, row - 1, col) || dfs(maze, row, col + 1) || dfs(maze, row, col - 1));
                }

                /**
                 * This method runs the search through all entrances
                 * @param maze  This is the traversed maze.
                 * @return  This is a boolean return type that returns true if an exit was found.
                 */
                public static boolean findExit(int [] [] maze){
                    for (int i = 0; i < maze.length; i++) {
                       if (dfs(maze, i, 0)||dfs(maze, 0, i)) return true;
                    }
                    return false;
                }
                /**
                 * This is the main method that runs the depth first search through all entrances
                 *
                 * @param args
                 */
                public static void main(String[] args) {
                    System.out.println(findExit(theMaze));
                }
            }
          </code>
        </pre>
        <br><br>
      </p>
    </article>
  </main>
  
  <footer>
    <p>
      Copyright 2019 Jae Park
    </p>
  </footer>
</body>
</html>
